////////////////////////////////////////////////////////////////////////////////
// Copyright Â© 2018 Privategrity Corporation                                   /
//                                                                             /
// All rights reserved.                                                        /
////////////////////////////////////////////////////////////////////////////////
package precomputation

import (
	"gitlab.com/elixxir/crypto/cyclic"
	"gitlab.com/elixxir/crypto/large"
	"gitlab.com/elixxir/server/globals"
	"gitlab.com/elixxir/server/services"
	"testing"
)

// Not sure if the input data represents real data accurately
// Expected data was generated by the cryptop.
// Right now this tests for regression, not correctness.
func TestPrecompDecrypt(t *testing.T) {
	test := 3
	pass := 0
	batchSize := uint64(3)
	grp := cyclic.NewGroup(large.NewInt(17), large.NewInt(5), large.NewInt(7))
	globals.Clear(t)
	globals.SetGroup(&grp)
	round := globals.NewRound(batchSize, globals.GetGroup())

	round.CypherPublicKey = globals.GetGroup().NewInt(13)

	var im []services.Slot

	im = append(im, &PrecomputationSlot{
		Slot:                         uint64(0),
		MessageCypher:                globals.GetGroup().NewInt(12),
		AssociatedDataCypher:         globals.GetGroup().NewInt(7),
		MessagePrecomputation:        globals.GetGroup().NewInt(3),
		AssociatedDataPrecomputation: globals.GetGroup().NewInt(8),
	})

	im = append(im, &PrecomputationSlot{
		Slot:                         uint64(1),
		MessageCypher:                globals.GetGroup().NewInt(2),
		AssociatedDataCypher:         globals.GetGroup().NewInt(4),
		MessagePrecomputation:        globals.GetGroup().NewInt(9),
		AssociatedDataPrecomputation: globals.GetGroup().NewInt(16),
	})

	im = append(im, &PrecomputationSlot{
		Slot:                         uint64(2),
		MessageCypher:                globals.GetGroup().NewInt(14),
		AssociatedDataCypher:         globals.GetGroup().NewInt(99),
		MessagePrecomputation:        globals.GetGroup().NewInt(96),
		AssociatedDataPrecomputation: globals.GetGroup().NewInt(5),
	})

	round.R_INV[0] = globals.GetGroup().NewInt(5)
	round.U_INV[0] = globals.GetGroup().NewInt(9)
	round.Y_R[0] = globals.GetGroup().NewInt(15)
	round.Y_U[0] = globals.GetGroup().NewInt(2)

	round.R_INV[1] = globals.GetGroup().NewInt(8)
	round.U_INV[1] = globals.GetGroup().NewInt(1)
	round.Y_R[1] = globals.GetGroup().NewInt(13)
	round.Y_U[1] = globals.GetGroup().NewInt(6)

	round.R_INV[2] = globals.GetGroup().NewInt(38)
	round.U_INV[2] = globals.GetGroup().NewInt(100)
	round.Y_R[2] = globals.GetGroup().NewInt(44)
	round.Y_U[2] = globals.GetGroup().NewInt(32)

	expected := [][]*cyclic.Int{{
		globals.GetGroup().NewInt(11), globals.GetGroup().NewInt(10),
		globals.GetGroup().NewInt(12), globals.GetGroup().NewInt(9),
	}, {
		globals.GetGroup().NewInt(11), globals.GetGroup().NewInt(2),
		globals.GetGroup().NewInt(15), globals.GetGroup().NewInt(1),
	}, {
		globals.GetGroup().NewInt(14), globals.GetGroup().NewInt(6),
		globals.GetGroup().NewInt(11), globals.GetGroup().NewInt(5),
	}}

	dispatch := services.DispatchCryptop(
		globals.GetGroup(), Decrypt{}, nil, nil, round)

	for i := 0; i < len(im); i++ {

		dispatch.InChannel <- &(im[i])
		actual := <-dispatch.OutChannel

		act := (*actual).(*PrecomputationSlot)

		expectedVal := expected[i]

		if act.MessageCypher.Cmp(expectedVal[0]) != 0 {
			t.Errorf("Test of Precomputation Decrypt's cryptop failed Message"+
				"Keys Test on index: %v\n\tExpected: %#v\n\tActual:   %#v", i,
				expectedVal[0].Text(10), act.MessageCypher.Text(10))
		} else if act.AssociatedDataCypher.Cmp(expectedVal[1]) != 0 {
			t.Errorf("Test of Precomputation Decrypt's cryptop failed Recipient"+
				"Keys Test on index: %v\n\tExpected: %#v\n\tActual:   %#v", i,
				expectedVal[1].Text(10), act.AssociatedDataCypher.Text(10))
		} else if act.MessagePrecomputation.Cmp(expectedVal[2]) != 0 {
			t.Errorf("Test of Precomputation Decrypt's cryptop failed Message"+
				"Cypher Test on index: %v\n\tExpected: %#v\n\tActual:   %#v", i,
				expectedVal[2].Text(10), act.MessagePrecomputation.Text(10))
		} else if act.AssociatedDataPrecomputation.Cmp(expectedVal[3]) != 0 {
			t.Errorf("Test of Precomputation Decrypt's cryptop failed Recipient"+
				"Cypher Test on index: %v\n\tExpected: %#v\n\tActual:   %#v", i,
				expectedVal[3].Text(10), act.AssociatedDataPrecomputation.Text(10))
		} else {
			pass++
		}
	}

	println("Precomputation Decrypt:", pass, "out of", test, "tests passed.")
}
