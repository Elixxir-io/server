package precomputation

import (
	"gitlab.com/privategrity/crypto/cyclic"
	"gitlab.com/privategrity/server/server"
	"gitlab.com/privategrity/server/services"
	"testing"
)

// Not sure if the input data represents real data accurately
// Expected data was generated by the cryptop.
// Right now this tests for regression, not correctness.
func TestPrecompDecrypt(t *testing.T) {
	test := 2
	pass := 0
	batchSize := uint64(2)
	round := server.NewRound(batchSize)
	gen := cyclic.NewGen(cyclic.NewInt(0), cyclic.NewInt(1000))
	group := cyclic.NewGroup(cyclic.NewInt(17), cyclic.NewInt(5), gen)

	round.R_INV[0] = cyclic.NewInt(5)
	round.U_INV[0] = cyclic.NewInt(9)
	round.Y_R[0] = cyclic.NewInt(15)
	round.Y_U[0] = cyclic.NewInt(2)
	round.R_INV[1] = cyclic.NewInt(8)
	round.U_INV[1] = cyclic.NewInt(1)
	round.Y_R[1] = cyclic.NewInt(13)
	round.Y_U[1] = cyclic.NewInt(6)
	round.CypherPublicKey = cyclic.NewInt(13)
	server.G = cyclic.NewInt(7)

	dispatch := services.DispatchCryptop(
		&group, PrecompDecrypt{}, nil, nil, round)

	var inputMessages []*services.Message
	inputMessages = append(inputMessages, &services.Message{
		uint64(0), []*cyclic.Int{
			cyclic.NewInt(12), cyclic.NewInt(7),
			cyclic.NewInt(3), cyclic.NewInt(8),
		}})
	inputMessages = append(inputMessages, &services.Message{
		uint64(0), []*cyclic.Int{
			cyclic.NewInt(2), cyclic.NewInt(4),
			cyclic.NewInt(9), cyclic.NewInt(16),
		}})

	expected := [][]*cyclic.Int{{
		cyclic.NewInt(11), cyclic.NewInt(10),
		cyclic.NewInt(12), cyclic.NewInt(9),
	}, {
		cyclic.NewInt(16), cyclic.NewInt(13),
		cyclic.NewInt(2), cyclic.NewInt(1)},
	}

	for i := 0; i < len(inputMessages); i++ {
		thisTestOK := true
		dispatch.InChannel <- inputMessages[i]
		actual := <-dispatch.OutChannel
		for j := 0; j < len(actual.Data); j++ {
			if actual.Data[j].Cmp(expected[i][j]) != 0 {
				thisTestOK = false
				t.Error("PrecompDecrypt: actual != expected",
					"in test case", i, "index", j)
				t.Error("Actual was", actual.Data[j].Text(10),
					"; expected was", expected[i][j].Text(10))
			}
		}

		if thisTestOK {
			pass++
		}
	}

	println("PrecompDecrypt:", pass, "out of", test, "tests passed.")
}
