package cryptops

import (
	"gitlab.com/privategrity/crypto/cyclic"
	"gitlab.com/privategrity/server/server"
	"gitlab.com/privategrity/server/services"
	"testing"
)

func TestPrecompGeneration(t *testing.T) {

	test := 102
	pass := 0

	bs := uint64(100)

	round := server.NewRound(bs)

	defaultInt := cyclic.NewInt(0)
	defaultInt.SetBytes(cyclic.Max4kBitInt)

	var im []*services.Message

	for i := uint64(0); i < bs; i++ {
		im = append(im, &services.Message{uint64(i), []*cyclic.Int{cyclic.NewInt(int64(0))}})
	}

	gen := cyclic.NewGen(cyclic.NewInt(0), cyclic.NewInt(1000))

	g := cyclic.NewGroup(cyclic.NewInt(11), cyclic.NewInt(5), gen)

	dc := services.DispatchCryptop(&g, PrecompGeneration{}, nil, nil, round)

	roundcnt := 0

	for i := uint64(0); i < bs; i++ {

		dc.InChannel <- im[i]
		rtn := <-dc.OutChannel

		if !validRound(round, defaultInt, i) {
			t.Errorf("Test of PrecompGeneration's random generation failed at index: %v ", i)
		} else if rtn.Slot != i {
			t.Errorf("Test of PrecompGeneration's output index failed at index: %v", i)
		} else {
			pass++
		}

		if round.Permutations[i] == i {
			roundcnt++
		}

	}

	if round.Z.Cmp(defaultInt) == 0 {
		t.Errorf("Test of PrecompGeneration's random generation of the Global Cypher Key failed")
	} else {
		pass++
	}

	if roundcnt > 20 {
		t.Errorf("Test of PrecompGeneration's shuffle failed")
	} else {
		pass++
	}

	println("PrecompGeneration", pass, "out of", test, "tests passed.")

}

func validRound(round *server.Round, cmped *cyclic.Int, i uint64) bool {
	if round.R[i].Cmp(cmped) == 0 {
		return false
	} else if round.S[i].Cmp(cmped) == 0 {
		return false
	} else if round.T[i].Cmp(cmped) == 0 {
		return false
	} else if round.U[i].Cmp(cmped) == 0 {
		return false
	} else if round.V[i].Cmp(cmped) == 0 {
		return false
	} else if round.R_INV[i].Cmp(cmped) == 0 {
		return false
	} else if round.S_INV[i].Cmp(cmped) == 0 {
		return false
	} else if round.T_INV[i].Cmp(cmped) == 0 {
		return false
	} else if round.U_INV[i].Cmp(cmped) == 0 {
		return false
	} else if round.V_INV[i].Cmp(cmped) == 0 {
		return false
	} else if round.Y_R[i].Cmp(cmped) == 0 {
		return false
	} else if round.Y_S[i].Cmp(cmped) == 0 {
		return false
	} else if round.Y_T[i].Cmp(cmped) == 0 {
		return false
	} else if round.Y_U[i].Cmp(cmped) == 0 {
		return false
	} else if round.Y_V[i].Cmp(cmped) == 0 {
		return false
	} else {
		return true
	}
}

// Not sure if the input data would be reasonable given the results of previous steps
// Expected data was generated by the cryptop. Right now this tests for regression, not correctness.
func TestPrecompDecrypt(t *testing.T) {
	test := 2
	pass := 0
	batchSize := uint64(2)
	round := server.NewRound(batchSize)
	gen := cyclic.NewGen(cyclic.NewInt(0), cyclic.NewInt(1000))
	group := cyclic.NewGroup(cyclic.NewInt(17), cyclic.NewInt(5), gen)

	round.R_INV[0] = cyclic.NewInt(5)
	round.U_INV[0] = cyclic.NewInt(9)
	round.Y_R[0] = cyclic.NewInt(15)
	round.Y_U[0] = cyclic.NewInt(2)
	round.R_INV[1] = cyclic.NewInt(8)
	round.U_INV[1] = cyclic.NewInt(1)
	round.Y_R[1] = cyclic.NewInt(13)
	round.Y_U[1] = cyclic.NewInt(6)
	round.G = cyclic.NewInt(13)
	server.G = cyclic.NewInt(7)

	dispatch := services.DispatchCryptop(&group, PrecompDecrypt{}, nil, nil, round)

	var inputMessages []*services.Message
	inputMessages = append(inputMessages, &services.Message{uint64(0), []*cyclic.Int{
		cyclic.NewInt(12), cyclic.NewInt(7), cyclic.NewInt(3), cyclic.NewInt(8),
	}})
	inputMessages = append(inputMessages, &services.Message{uint64(0), []*cyclic.Int{
		cyclic.NewInt(2), cyclic.NewInt(4), cyclic.NewInt(9), cyclic.NewInt(16),
	}})

	expected := [][]*cyclic.Int{
		{cyclic.NewInt(11), cyclic.NewInt(10), cyclic.NewInt(12), cyclic.NewInt(9)},
		{cyclic.NewInt(16), cyclic.NewInt(13), cyclic.NewInt(2), cyclic.NewInt(1)},
	}

	for i := 0; i < len(inputMessages); i++ {
		thisTestOK := true
		dispatch.InChannel <- inputMessages[i]
		actual := <-dispatch.OutChannel
		for j := 0; j < len(actual.Data); j++ {
			if actual.Data[j].Cmp(expected[i][j]) != 0 {
				thisTestOK = false
				t.Error("PrecompDecrypt: actual != expected in test case", i, "index", j)
				t.Error("Actual was", actual.Data[j], "and expected was", expected[i][j])
			}
		}

		if thisTestOK {
			pass++
		}
	}

	println("PrecompDecrypt:", pass, "out of", test, "tests passed.")
}
